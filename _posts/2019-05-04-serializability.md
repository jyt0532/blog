---
layout: post
title: Designing Data-Intensive Application - Transactions - 可串行化
comments: True 
subtitle: 事務 - 可串行化
tags: systemDesign 
author: jyt0532
excerpt: 本篇文章介紹事務中的可串行化
---

這是Designing Data-Intensive Application的第二部分第三章節的Part2: 可串行化

筆者註: 這個章節書中敘述的方式太過凌亂 對於初學者非常吃力 筆者改變了介紹的方式甚至例子都做了更改 在本部落格中將事務一章分為三篇文章

事務Part1 - ACID

事務Part2 - 弱隔離級別

事務Part3 - 可串行化

本篇是系列文的Part3

本文所有圖片或代碼來自於原書內容

{% include copyright.html %}


# 可串行化


我們在[Part2](/2019/04/29/weak-isolation-levels/)討論了各種不同的隔離程度 跟各種隔離程度可能會發生的並發問題 


| 隔離級別 | Dirty Write | Dirty Read | Non-repeatable read  | Phantom read
| --- | --- | --- | --- | --- |
| None | O | O | O | O |
| Read Uncommited      | X | O | O | O |
| Read Commited(Non-repeatable read) | X | X | O | O |
| Repeatable read      | X | X | X | O |
| Serializable      | X | X | X | X |

可串行化(Serializability)隔離通常被認為是最強的隔離級別 它保證即使事務可以並行執行 最終的結果也是一樣的 就好像它們沒有任何並發性一樣

換句話說 數據庫可以防止所有可能的競爭條件


目前大多數提供可串行化的數據庫都使用了三種技術之一:

1.就是真的一個一個執行

2.兩階段鎖(Two-phase locking)

3.樂觀並發控制技術???可序列化的快照隔離(serializable snapshot isolation)

本文會一一介紹以上的技術

## 就是真的一個一個執行

避免並發問題的最簡單方法就是完全不要並發

![Alt text]({{ site.url }}/public/DDIA/chou.jpeg)

如字面上所說 就是所有有可能動到同一個物件的事務 都一個一個執行 這個做法在以前是覺得可笑的 但最近卻又開始變得可行 原因如下

1.RAM越來越便宜 很多場合都已經可以[把所有數據都存在內存中](/2019/01/19/storage-and-retrieval/#在內存中存儲一切) 當所有

2.OLTP(事務處理)的操作通常都很直覺 只需要少量的讀寫操作 跟OLAP(分析系統)比起來非常快

### Store procedure(儲存程序)

儲存程序 指的就是把事務的應用邏輯封裝在資料庫裡

回顧一下之前醫院醫生oncall的例子

![Alt text]({{ site.url }}/public/DDIA/DDIA-7-8.png)

應用程式組裝了一個query 丟給資料庫執行 資料庫跑完回傳給應用程式看一下有沒有符合條件 有的話再組裝一個query丟給資料庫執行

如下圖的Interactive transaction
![Alt text]({{ site.url }}/public/DDIA/DDIA-7-9.png)

你看得出來 應用程序和數據庫之間的溝通耗費了大量的時間 如果我們不允許並發處理 而且一次只做一個事務 那吞吐量會相當悲劇 因為大部分的時間資料庫都在等應用程式發出下一個查詢

所以改進方式 就是儲存程序 我們把應用程式的邏輯直接告訴資料庫 讓他直接幫我們搞定 少了一次網路的傳輸

#### 儲存程序優缺點

存儲過程在關係型數據庫中已經存在了一段時間了 從1999年以來它們一直是SQL標準的一部分 但基於某些原因 大家以前都不太喜歡用

1.每個數據庫都有自己的存儲過程語言(Oracle有PL/SQL, SQL Server有T-SQL, PostgreSQL有PL/pgSQL等等) 這些語言並沒有跟上通用編程語言的發展 所以從今天的角度看 語法都非常醜陋陳舊

2.和在應用程式中跑程式比起來 在數據庫跑程式管理起來比較困難 debug困難 版本控制困難以及部署困難

3.數據庫通常對於性能的要求比在應用程式高上許多 在數據庫中一個寫得不好的儲存程序 會比程序在應用程式中帶來更大的麻煩

如今這些問題已經慢慢的被克服 許多現代的存儲放棄了PL/SQL 使用現有的編程語言 (VoltDB使用Java或Groovy, Datomic使用Java或Clojure, Redis使用Lua)

### 分區

雖然一個一個執行讓事情變得簡單 但吞吐量的上限就是單機單核的速度 如果請求大部分都是讀請求 還有機會在不同的機器使用相同快照處理 但如果請求大部分都是寫請求  那單線程事務處理器可能成為一個嚴重的瓶頸

如果你要擴展到多個CPU核心和多個節點 可以對數據進行[分區](/2019/03/12/partitioning/) 如果你找到可以很好的分區的方法 讓每個事務可以在不同的區擁有自己的事務線程 這樣吞吐量就可以跟CPU數量呈現性發展

但只要有一個事務需要同時訪問兩個不同分區的物件 那就需要數據庫在觸及的所有分區之間協調事務 這可能某種程度需要同時鎖住需要被訪問的分區 而通常這協調的開銷非常大

事務是否可以是劃分至單個分區很大程度上取決於應用數據的結構 簡單的key-value數據通常可以非常容易地進行分區 但是具有多個二級索引的數據可能需要大量的跨分區協調(參閱[分區和次級索引](/2019/03/12/partitioning/#分區和次級索引partitioning-and-secondary-indexes))

### 就是真的一個一個執行 總結

在特定約束條件下 真的一個一個執行事務 已經成為一種實現可序列化隔離等級的可行辦法

1.每個事務都必須小而快 只要有一個緩慢的事務 就會拖慢所有事務處理

2.通常很常被訪問的數據放進內存 不常被訪問的放進硬碟 所以如果事務需要訪問那些在硬碟裡的資料 就會變得非常慢

3.寫入吞吐量必須低到能在單個CPU核上處理 不然事務需要能劃分至單個分區 而且不需要跨分區協調

4.跨分區事務是可能的 但是它們的使用程度有很大的限制

## 兩階段鎖定(2PL)

大約30年來 在數據庫中只有一種廣泛使用的串行化算法 就是二階段鎖定 two-phase locking

> 注意: 2PL(2-phase locking) 不等於 2PC(2-phase commit) 它們是完全不同的東西

之前我們看到鎖通常用於[防止髒寫](/2019/04/29/weak-isolation-levels/#避免髒寫): 如果兩個事務同時嘗試寫入同一個對象 則鎖可確保第二個寫入必須等到第一個寫入完成事務(中止或提交)之後才能繼續

兩階段鎖定也很類似 但是卻更強 只要沒有寫入 就允許多個事務同時讀取同一個對象 但對象只要有寫入(修改或刪除) 就需要獨佔訪問(exclusive access)權限:

1.如果事務A讀取了一個對象 並且事務B想要寫入該對象 那麼B必須等到A提交或中止才能繼續

2.如果事務A寫入了一個對象 並且事務B想要讀取該對象 那麼B必須等到A提交或中止才能繼續

在2PL中 寫需求不僅會阻塞其他寫需求 也會阻塞讀需求 但讀需求只會阻塞其他寫需求

相比於[快照隔離](/2019/04/29/weak-isolation-levels/#快照隔離-snapshot-isolation)讀不阻塞寫 寫也不阻塞讀 讀寫會互相阻擋的前提下 我們避免了不可重複讀問題

### 實現2PL

讀與寫的阻塞是通過為數據庫中**每個對象添加鎖**來實現的 鎖可以處於共享模式(shared mode)或獨佔模式(exclusive mode) 實現方式如下:

1.如果事務要讀取一個對象 必須先以共享模式獲取鎖 共享鎖可以同時讓很多事務同時持有 但如果有一個事務已經在相同對象上持有排它鎖 則其他事務必須等待

2.若事務要寫入一個對象 它必須首先以獨佔模式獲取該鎖 其他人都不能再拿相同事務的共享鎖或是排他鎖 當然如果對象的鎖已經被拿走(不論是共享鎖或是排他鎖) 這個想寫的事務就必須等

3.如果事務需要先讀取再寫入對象 則它可能會將其共享鎖升級為獨佔鎖 升級鎖的工作與直接獲得排他鎖相同

4.事務獲得鎖之後 必須繼續持有鎖直到事務結束(提交或中止)

這就是為什麼這叫做兩階段鎖 第一階段(當事務正在執行時)獲取鎖，第二階段(在事務結束時)釋放所有的鎖

由於使用了這麼多的鎖 因此很可能會發生一種情況 事務A等待事務B釋放它的鎖 反之亦然 這種情況叫做死鎖 現在大部分的數據庫會自動檢測事務之間的死鎖 並由應用程式重試

### 2PL的性能

可想而知 2PL最大的缺點就是性能問題 兩階段鎖定下的事務吞吐量與查詢響應時間要比弱隔離級別下要差得多

主要原因是獲取跟釋放鎖的開銷很大 基本上你想要寫一個對象 你要先等其他也在這個對象做事的事務結束

而且運行2PL的數據庫可能具有相當不穩定的延遲 特別是P95, P99的延遲通常特別高 你只需要一個緩慢的事務或是存取大量數據的事務 就可以把系統的其他部分拖慢

最後 2PL的隔離級別中 死鎖會發生的很頻繁 解死鎖也需要開銷 

### Predicate locks

該辦正事了 我們一直還沒處理[幻讀](/2019/04/29/weak-isolation-levels/#幻讀)的問題: **一個事務改變另一個事務的搜索查詢的結果** 我們也知道一個具有可序列化隔離級別的數據庫必須防止幻讀

當我們要預訂一個會議室的時候 如果一個事務在某個時間窗口內**搜索**了一個房間的現有預訂 另一個事務**不能同時插入或更新**同一時間窗口與同一房間的另一個預訂

要實現這一點 我們需要Predicate lock 它類似於前面描述的共享/排它鎖 但是不屬於特定的對象 他符合**某些**符合某些搜索條件的對象

看個例子
{% highlight sql %}
SELECT * FROM bookings
WHERE room_id = 123 AND
      end_time > '2018-01-01 12:00' AND 
      start_time < '2018-01-01 13:00';
{% endhighlight %}

### Index-range locks
