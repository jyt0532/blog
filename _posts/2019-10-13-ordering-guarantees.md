---
layout: post
title: Designing Data-Intensive Application - Consistency and Consensus
comments: True 
subtitle: 一致性和共識
tags: systemDesign 
author: jyt0532
excerpt: 本文講解一致性和共識
---

這是Designing Data-Intensive Application的第二部分第五章節Part3: 順序保證

一致性和共識Part1 - 介紹

一致性和共識Part2 - 線性一致性

一致性和共識Part3 - 順序保證

一致性和共識Part4 - 分佈式事務與共識

本文所有圖片或代碼來自於原書內容
{% include copyright.html %}

# 順序保證

線性一致代表說一個系統表現得好像只有一個數據副本 而且每個操作都是以原子性的方式生效 這個定義代表每個操作是按照某種良好定義的順序執行的

順序(ordering)這一主題在本書中反覆出現 這表明它是一個重要的基礎性概念 讓我們複習一下之前看到順序的地方

1.[複製](/2019/02/12/replication/)一章中 單主複製的領導者有一個很重要的任務 就是要在複製日誌中確定寫入順序(order of write) 來讓從庫遵從這個順序 如果沒有一個領導者的話 並發操作可能導致[衝突](/2019/02/12/replication/#處理寫入衝突)

2.[可序列化](/2019/05/11/serializability/)是關於事務表現的像按**某種序列順序執行的保證**

3.[第八章](/2019/10/05/the-trouble-with-distributed-systems/)我們討論在分佈式系統中使用[時間戳和時鐘](/2019/10/05/the-trouble-with-distributed-systems/#依賴同步時鐘) 我們常需要去決定哪一個寫比較早發生


我們發現 順序 線性一致性和共識之間有著深刻的聯結

## 順序與因果

順序反覆出現有幾個原因 其中一個原因是它有助於保持因果關係(causality)

因果關係對事件施加了一個順序 因在果之前 消息發送在消息收取之前 如果一個系統服從因果關係所規定的順序 我們說它是**因果一致(causally)**的系統

### 因果順序不是全序的 causal order is not a total order

全序(total order)允許兩個元素任意比較 所以一個集合內有兩個元素彼此都可以任意比較 那麼這個集合就是total order 比如說自然數的集合是全序的

可是很多其他的數學集合不是全序的 比如說`{a, b}`和`{b, c}`我們無法比較 所以數學集合是篇序(partially order)的 在某些情況下也許我們可以說`{a,b,c}`比`{a,b}`大 但其他情況下基本上不行

為什麼講這個呢 我們回頭來看
全序和偏序之間的差異反映在不同的數據庫一致性模型中:

線性一致性: 在線性一致的系統中 操作是全序的 因為如果系統表現得好像只有一個副本 且所有操作都是原子性 那麼對於任意兩個操作 我們總是能比較說哪個先發生

因果性: 如果兩個操作都沒有在**彼此之前發生** 那麼這兩個操作是並發(concurrent)的 如果是並發的 那麼它們之間的順序是無法比較的 這意味著因果關係定義了一個偏序而非全序 某些操作間可以比較順序 某些操作間無法比較順序

### 線性一致性強於因果一致性

我們一直在講因果順序跟線性一致 到底這兩者的關係是什麼呢 答案是 線性一致性**隱含著(implies)**因果關係 也就是說任何線性一致性的系統都能正確保持因果性

可是我們剛剛說了 A跟C只能選一個 如果你真的非要線性一致性 那可用性就無法太過要求 特別是在網路有延遲的情況下 更不用說為了符合線性一致所帶來的性能損失

所以現在大多數的系統 選擇**只要符合因果一致性就好了** 這樣性能的損失也不會太大 

>> 事實上 在所有的不會被網路延遲拖慢的一致性模型中 因果一致性是可行的最強的一致性模型

#### 捕獲因果關係

所以現在我們只需要維持因果一致就可以 而不需要線性一致

當一個並發操作發生了 理論上這些並發操作可以以任何順序被處理 但是要確定的是 **在每一個副本上你都必須以一樣的順序處理** 不能說在副本A 操作1先處理再換操作2 但在副本B中 操作2先處理再換操作1 

所以當一個副本處理操作時 他必須確定所有在這個操作之前的所有操作都被處理完了 如果前面的操作丟失了 後面的操作必須等待 直到前面的操作被處理完畢

那麼對於每個節點來說 怎麼確定因果依賴呢 我們曾經討論過用來確定[**哪些操作發生在哪些操作之前**的技術](/2019/02/12/replication/#檢測並發寫入) 我們討論了無領導者數據存儲中的因果性 為了防止更新丟失 我們需要檢測到對同一個key的並發寫入 但因果關係需要更進一步 我們需要檢測整個資料庫的並發寫入 而不是只是一個單獨的key 通常用版本向量解

為了維持因果性 你需要知道哪個操作發生在哪個操作之前 

## 序列號順序

雖然因果是一個重要的理論概念 但實際上跟蹤所有的因果關係是不切實際的 在許多應用中客戶端在寫入內容之前會先讀取大量數據 我們無法弄清寫入因果依賴於先前全部的讀取內容 顯式跟蹤所有已讀數據意味著巨大的額外開銷

### 全序廣播

## 分佈式事務與共識

### 原子提交與二階段提交(2PC)

### 實踐中的分佈式事務

### 容錯共識

### 成員與協調服務

## 總結
