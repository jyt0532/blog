---
layout: post
title: Designing Data-Intensive Application - Distributed Transaction and Consensus
comments: True 
subtitle: 分佈式事務與共識
tags: systemDesign 
author: jyt0532
excerpt: 本文講解一致性和共識
---

這是Designing Data-Intensive Application的第二部分第五章節Part4: 分佈式事務與共識

一致性和共識Part1 - 介紹

一致性和共識Part2 - 線性一致性

一致性和共識Part3 - 順序保證

一致性和共識Part4 - 分佈式事務與共識

本文所有圖片或代碼來自於原書內容
{% include copyright.html %}


# 分佈式事務與共識

共識是分佈式計算中最重要也是最基本的問題之一 目標是讓數個節點達成一致

節點達成一致這件事 在很多場景都很重要 比如說

1.領導選舉:在單主複製的數據庫中 所有節點需要就哪個節點是領導者達成一致 如果一些節點網路故障 可能會對領導權的歸屬產生爭議 因為錯誤的故障切換(failover)會導致兩個節點都認為自己是領導者(也就是腦裂 參閱[處理節點停機](/2019/02/12/replication/#section-4)) 而如果有兩個領導者 那寫入就會產生分歧

2.原子提交:在支持跨多節點數據庫中 一個事務可能在某些節點上失敗 但在其他節點上成功 如果我們要維持原子性 則我們必須要讓所有節點對事務的結果達成一致 要馬全部提交 要馬全部中止回滾

在本節中 我們會研究原子提交問題 常見的算法是2PC(two-phase commit) 這個算法很頻繁的在各種數據庫 消息隊列和應用服務器中被實現

$$$$
通過對2PC的學習 我們將繼續努力實現更好的一致性算法，比如ZooKeeper（Zab）和etcd（Raft）中使用的算法

$$$$$$$$$$$$


## 原子提交與二階段提交(2PC)

原子性 指的是事務的結果要馬是成功提交(事務的所有寫入都是持久化的) 要馬是中止(事務的所有寫入都被回滾)

這個性質可以防止事務的失敗導致數據庫進入半成品狀態或是半更新狀態 對於[多對象事務](/2019/04/21/transactions/#section-2)和維護次級索引(如果你修改了一些數據 你還需要在輔助索引中進行相應的更改)的數據庫特別重要 

### 從單節點原子提交到分佈式原子提交

先複習一下單節點我們怎麼實現原子提交 我們通常就由**存儲**來搞定

當客戶端請求數據庫節點提交事務時 數據庫將事物的寫入durable(通常使用WAL 參閱[讓B-tree更可靠](/2019/01/19/storage-and-retrieval/#讓b-tree更可靠)) 然後將提交記錄追加到磁盤中的日誌裡 如果數據庫在這過程中崩潰的話 我們會再重啟時從日誌中恢復 所以一切以提交記錄的為準 如果提交記錄在崩潰之前成功地寫入磁盤 那就認為事務被提交 反之則視為未被提交

總之 在單個節點上 事務的提交主要取決於數據持久化的順序


## 實踐中的分佈式事務

## 容錯共識

## 成員與協調服務

## 總結
