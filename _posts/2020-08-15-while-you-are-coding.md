---
layout: post
title: While You Are Coding - 當您寫程式時
comments: True 
subtitle: While You Are Coding
tags: pragmaticProgrammer
author: jyt0532
excerpt: 本文記錄了讀完The Pragmatic Programmer的讀後筆記
---

千呼萬喚 終於等到[Pragmatic Programmer 20週年紀念版](http://books.gotop.com.tw/v_ACL057200) 如果沒聽過這本書 你大概也聽過[程序員修煉之道︰從小工到專家](https://www.books.com.tw/products/CN10279423)這本暢銷了20年的書 終於等到了再版 

在再版裡面 刪掉了比較過時的內容和範例 收集了20年來收到的feedback 在讓這本書的內容也可以適用於2020年的程序員 但在我細細品嚐後發現 其實很多人生的哲學並不是只適用於程序員 各行各業看了都可以有所收穫

因為每個篇章的篇幅都不長 所以筆記也用條列式紀錄

本篇的圖片以及程式碼來自於原書內容

{% include copyright.html %}

# 第七章: 當您寫程式時

## 聆聽你的蜥蜴腦

> 人類有三種腦 分別是蜥蜴腦 猴子腦以及人類腦 蜥蜴腦掌管習慣性的動作 猴子腦掌管情緒 人類腦思慮周延且理性 能有效地解決問題    ---- Rory Miller

直覺是我們大腦潛意識對模式的一種反應 有些是天生的 有些是透過重複學習而習得的 日常生活中的直覺 也是一樣 看到某些可能危險的東西不去靠近 都是生物演化的本能 

身為一名程式設計師 當你累積了經驗 你的大腦就會逐漸形成一層又一層的隱性知識 包含某些東西可能沒有用 某些東西可能很好 某些東西可能導致錯誤 或者某件事情實在太麻煩了 不應該這麼做

直覺不會說話 你必須要感覺到直覺的發生 然後找出發生的原因  因為這是你身為工程師的經驗的總結 用最快的速度給你反饋

### 怎麼跟蜥蜴腦交談呢
@@@@@@@@@@@@ NOT FINISHED YET

## 靠巧合寫程式

記不記得以前我們看戰爭片的時候 想像一個士兵在灌木叢中小心翼翼地前進 前面的一塊空地可能有地雷 於是士兵就小心翼翼的戳前面的地面 邊戳邊走 走了一陣子發現都沒爆炸 於是覺得這塊地沒問題 然後昂首向前走的時候就踩到地雷了

這個士兵當初對地雷的探測沒有報 純粹是運氣好 卻因為運氣好導致了一個錯誤的結論 

身為開發者 我們也是在地雷區工作 每天有上百上千個陷阱等著我們 我們應該避免利用巧合 而是有意識地寫程式

### 如何靠巧合寫程式

我們常常會遇見**實作中的偶然情況** 單純是因為程式碼的撰寫方式讓你可以依賴邊界條件或是沒人了解的意外情況

假設你在呼叫一個函式 傳入了錯誤資料 這個函式以特定的方式回應 你就以這個回應繼續寫你的程式碼 但該函式的作者根本就不是預期要那樣子回應你 等到那個韓式修復完成後 你的程式碼崩潰 但是你怎麼看都覺得你的程式應該要正常運作


比如說Fred想要在螢幕上顯示一些東西

{% highlight python %}
paint();
invalidate();
validate();
revalidate();
repaint();
paintImmediately();
{% endhighlight %}

這些函示並不是被設計成以這樣的順序被呼叫的 雖然這麼跑起來結果看起來對 但那只是湊巧

最糟糕的是 因為跑起來對 Fred就不冒著把跑起來正確的程式搞壞的風險去修改它 但身為一個務實工程師 你必須要思考

1.它可能沒有真正發揮作用 可能只是看起來有作用

2.你所依賴的邊界條件只是一個意外 在不同的環境中(螢幕解析度 CPU數量) 跑起來結果可能不同

3.為按照設計使用的行為 可能在函式庫更新下一個版本的時候 你的程式就會改變了

4.額外且不必要的呼叫會讓你的程式變慢

5.額外的呼叫增加了引入新bug的風險

#### Correlation does not imply causation

人類天生就擅長發現模式和原因 比如俄羅斯領導人總是禿頭跟沒禿頭交替領導 雖然你寫程式不會依賴於這麼假設 但現實生活很多明明就是獨立的事件卻讓你感覺彼此有關聯

但相關並不表示因果關係 簡單的例子就是 

"電視看多的小孩大多比較暴力 所以看電視會導致暴力" 這句話的因果關係很可能是錯的 因為你也可以解讀成 暴力的人比較喜歡看電視

比如說一個log檔案顯示 每1000個請求就有一個間接性錯誤 這個錯誤可能是race condition 也可能是bug 只在測試伺服器上發生 這可能是不同環境之間的巧合 也可能是真的有bug

不要假設 找出為什麼並且證明


### 如何謹慎的寫程式

我們希望花費更少的時間來寫程式碼 希望儘早的捕獲開發時期的錯誤 這需要謹慎的開發程式

1.時刻注意自己在做什麼

2.你能像一個初階工程師解釋你的程式碼嗎 如果不能 那你可能就是在靠巧合寫程式

3.不要在黑暗中寫程式碼 比如寫一個你沒完全掌握的應用 或是使用一個你不理解的技術 畢竟如果你不知道為什麼一個東西可以正常工作 你就不會知道一個東西為什麼會出錯

4.從做計畫開始 可能是在腦子裡 可能是在白板上

5.把你的假設記錄下來 

6.不要只是測試你的程式碼 還要測試你的假設

7.優先考慮要把心力放在哪裡 如果沒有正確的架構 那程式再華麗都沒用

8.不要讓現在的程式碼支配未來的程式碼 如果程式碼不再合適 所有的程式碼都是可以替換的 隨時做好重構的心理準備


總之 下次當有件事情看起來可行 但你不知道為什麼 請確保這不是一個巧合


## 重構

重構就是重組現有的程式碼主體 改變內部結構而不改變外部行為的技術

基本上講的都是[重構 - 改善既有程式的設計](/toc/refactoring/)的東西

## 測試對程式碼的意義

> 測試的目的不是要找出bug

測試的好處是發生在你思考和撰寫程式碼時 而不是執行測試的當下

### 測試驅動開發

TDD(Test-Driven Development)的基本循環為

1.決定要添加的一小部分功能

2.寫一個測試專門測試該功能

3.執行所有測試 確認唯一的失敗是剛剛寫的測試

4.撰寫使測試通過的最少程式碼 並驗證剛剛寫的測試通過了

5.重構程式碼 別忘了邊重構邊確保測試一直通過

這個週期應該非常短 大概幾分鐘一個週期 這樣你就可以不斷的寫測試 讓他們work

### 測試的文化

你撰寫的所有軟體都將被測試 如果不是被你或你的團隊測試 就是被你的客戶測試 既然如此 你不如就提前進行徹底的測試 來減低維護成本和客服的電話

對待測試就像對待其他任何的產品一樣 需要保持去耦合性 簡潔性和健壯性 不要依賴不可靠的東西 比如UI中某個元件的絕對位置 或是伺服器log的某個timestamp

> Testing, design, coding — it’s all programming.

## 以屬性為基礎的測試



## 待在安全的地方

## 命名


![Alt text]({{ site.url }}/public/pragmatic-programmer-1.png)

{% highlight python %}
case_semaphore.lock()
if display_case.pie_count > 0
  promise_pie_to_customer()
  display_case.take_pie()
  give_pie_to_customer()
end
case_semaphore.unlock()
{% endhighlight %}

XXXXXXXXXXXXXXXXXXXXXXXXXXXXx

什麼是時間耦合(temporal coupling)呢 我們很常在寫程式的時候 寫出類似這樣的邏輯

先做A -> 再做B 等等

B要等到A結束之後再做 但其實這種方法不是很彈性 也不太符合現實 會這麼做的原因往往只是我們學寫程式的時候 都是從sequential的程式語言開始學

如果**做B**這件事不依賴**做A** 那我們應該要讓並行發生 **去掉時間或順序所產生的耦合** 這樣我們可以獲的很多彈性 並且減少時間上的依賴

### 尋找並行

我們要在專案中 找出哪些操作可以同時發生 哪些操作必須嚴格的照順序發生 常見的方法是使用UML中的activity diagram

來看一下酒保怎麼做出飲料


![Alt text]({{ site.url }}/public/pragmatic-programmer-1.png)

看了流程之後 你發現其實步驟 1, 2, 4, 10, 11 可以在一開始就並行的去做 做完1,2,4之後 3,5,6又可以並行的去做 所以要是每個任務的單位時間一樣 原本需要12個單位的時間 如果可以成功並行 那就只需要6個單位時間

### 並行的機會

雖然我們看到了並行的可能 但並不表示這些地方真的可以如我們所願的並行 剛剛說的6個單位時間的完成法 酒保必須要有5雙手才可以達成

所以在程式碼中 我們想要找出**耗費時間的任務** 但這任務卻又不是在執行程式碼 比如說查詢資料庫 存取外部服務 等待使用者輸入 等等 這些事情會讓程式停滯 這些停滯的時候就是處理並行的好時機

### 平行的機會

記住兩者的區別 並行是個軟體機制 平行是個硬體機制

如果我們有多個處理器 我們就可以為他們分配 可以平行拆分的工作  然後再合併結果

### 要找出並行和平行的機會並不難

找出機會不難 難的是如何安全地實現 本文接下來的章節會討論安全實現的問題

## 不要共用狀態 

假設你在一家餐廳 你問服務生有沒有蘋果派 服務生轉頭看了一下烤箱還有最後一個 於是你就點了蘋果派

但在同一個時間 有另一個客人也問一樣的問題 也點了蘋果派 那這家餐廳就出包了 一定有一個客人吃不到

> Shared State Is Incorrect State

### 非原子性的更新

簡單的來看一下程式碼

![Alt text]({{ site.url }}/public/pragmatic-programmer-2.png)


雖然現實生活中 這兩個服務員是平行工作 因為這兩個服務員幾乎同時執行程式碼 同時認為`display_case.pie_count > 0` 所以兩個都執行`display_case.take_pie()` 

這裡的問題不是兩個人共用記憶體 問題是出在兩個人無法保證他們對記憶體的看法一致 因為當他們要看剩多少派的時候 需要先把共享記憶體的資料複製到私人記憶體 再來做判斷 但在判斷的時候可能資料已經過時了

那要怎麼確保原子性呢

### Semaphor

Semaphor就是個最簡單的鎖 當服務生手上握著鎖的時候 才可以幫忙點餐

{% highlight python %}
case_semaphore.lock()
if display_case.pie_count > 0 
  promise_pie_to_customer() 
  display_case.take_pie() 
  give_pie_to_customer()
end
case_semaphore.unlock()
{% endhighlight %}

### 非交易型更新

共用記憶體身為並行性問題的根源 自然受到了很多關注 事實上 只要是任何應用程式程式碼可共用可變資源 都可能出現問題

> Random Failures Are Often Concurrency Issues

除了semaphor 其他隊共用資源的獨佔存取包含mutex, monitor等等

這些需要外在的枷鎖才可以正確存取共用狀態的方法很複雜 也很容易出錯 有沒有簡單一點的方式來寫並行的程式呢??

## 參與者模型 Actor model

什麼是Actor呢  就是一個獨立的虛擬處理器 有著自己的狀態和郵箱 當你的郵箱有了新的訊息而且參與者有空的話 就會處理這個訊息 一路處理到郵箱的所有訊息處理完後 又進入空閒狀態

關於Actor 有幾個重要的特質

1.系統內沒有東西是可控的 沒有人能安排接下來要發生什麼 也沒有人可以安排從原始資料到最終輸出的資訊傳輸

2.系統的唯一狀態被保存在訊息之中 還有每個參與者的本地狀態 

3.除了接收端可以檢查訊息之外 沒有人可以看到參與者收到的訊息 除了參與者之外 也沒有人可以存取參與者的本地狀態

4.**所有的資訊都是單向的** 沒有回覆的概念 如果你希望參與者回應 你就要在訊息裡面寫好自己的郵箱地址 然後參與者會再發另一條消息到指定的郵箱

5.參與者處理每條訊息直到完成 並且一次只處理一條訊息

因此 參與者的執行是並行 非同步 而且不共用任何內容的

> 使用參與者模型可以做到不共用狀態的並行工作


### 實作參與者模型的語言

Erlang/Elixir 有興趣的話可以看他們怎麼有效的使用參與者模型 增加應用的可靠程度













